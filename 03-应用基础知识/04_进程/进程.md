# 进程

## 1. 进程基本知识

1. 进程概念：进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。

2. 进程号：Linux 系统下的每一个进程都有一个进程号（process ID，简称 PID），进程号是一个正数，用于唯一标识系统中的某一个进程。在 Ubuntu 系统下执行 ps 命令可以查到系统中进程相关的一些信息。

   进程号的作用就是用于唯一标识系统中某一个进程，在某些系统调用中，进程号可以作为传入参数、有时也可作为返回值。

   ```shel
   查看进程信息：ps -aux    -ajx//查看PPID,PID,PGID,SID
   获取本进程PID：pid_t getpid(void);
   获取父进程PID：pid_t getppid(void);
   ```

3. 进程的环境变量：每一个进程都有一组与其相关的环境变量，这些环境变量以字符串形式存储在一个字符串数组列表中， 把这个数组称为环境列表。其中每个字符串都是以“名称=值（name=value）”形式定义，所以环境变量是 “名称-值”的成对集合

   ```shell
   查看shell进程的所有环境变量：env
   添加一个新的环境变量或删除一个环境变量：export//添加，export -n//删除
   ```

## 2. 进程的内存布局

1. c语言程序构成

   - 程序代码段：CPU 执行的机器语言指令部分，具有只读属性，可共享
   - 数据段：显式初始化的全局变量和静态变量
   - 未初始化数据段：未进行显式初始化的全局变量和静态变量，通常将此段称为 bss 段；在程序开始执行之前，系统会将本段内所有内存初始化为 0
   - 栈：栈是一个动态增长和收缩的段，由栈帧组成，系统会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量、实参和返回值。
   - 堆：可在运行时动态进行内存分配的一块区域，譬如使用 malloc()分配的内存空间，就是从系统堆内存中申请分配的。

   ![内存分布图](..\image\内存分布图.png)

   ```she
   查看二进制可执行文件的文本段、数据段、bss 段的段大小:size
   ```

2. 虚拟地址会通过硬件 MMU（内存管理单元）映射到实际的物理地址空间中，建立虚拟地址到物理地址的映射关系后，对虚拟地址的读写操作实际上就是对物理地址的读写操作；Linux 系统下，应用程序运行在一个虚拟地址空间中，所以程序中读写的内存地址对应也是虚拟地址， 并不是真正的物理地址。

## 3. 创建进程

1. 一个现有的进程可以调用 fork()函数创建一个新的进程，调用 fork()函数的进程称为父进程，由 fork()函数创建出来的进程被称为子进程（child process）

   ```shell
   创建进程：pid_t fork(void);//fork()调用成功后，将会在父进程中返回子进程的 PID，而在子进程中返回值是 0；如果调用失败，父进 程返回值-1，不创建子进程，并设置 errno。
   ```

2. 在一个大型的应用程序任务中，创建子进程通常会简化应用程序的设计，同时提高了系统的并发性（即同时能够处理更多的任务或请求，多个进程在宏观上实现同时运行）。

3. 子进程拷贝了父进程的数据段、堆、栈以及继承了父进程打开的文件描述符，父进程与子进程并不共享这些存储空间，这是子进程对父进程相应部分存储空间的完全复制；但是对于程序代码段（文本段）来说，两个进程执行相同的代码段， 因为代码段是只读的，也就是说父子进程共享代码段，在内存中只存在一份代码段数据。

4. 子进程被创建出来之后，便是一个独立的进程，拥有自己独立的进程空间，系统内唯一的进程号，拥有自己独立的 PCB（进程控制块），子进程会被内核同等调度执行，参与到系统的进程调度中。

## 4. 父子进程文件共享

1. fork()函数使用场景

   - 父进程希望子进程复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的，父进程等待客户端的服务请求，当接收到客户端发送的请求事件后，调用 fork()创建一个子进程，使子进程去处理此请求、而父进程可以继续等待下一个服务请求。
   - 一个进程要执行不同的程序。譬如在程序 app1 中调用 fork()函数创建了子进程，此时子进程是要去执行另一个程序 app2，也就是子进程需要执行的代码是 app2 程序对应的代码，子进程将从 app2 程序的 main 函数开始运行。这种情况，通常在子进程从fork()函数返回之后立即调用 exec 族函数 来实现。

   - 子进程调用\_exit()退出进程、而非使用 exit()，调用\_exit()在退出时便不会刷新 stdio 缓冲区。

## 5. 等待及监视子进程

1. 系统调用 wait()可以等待进程的任一子进程终止，同时获取子进程的终止状态信息。

   ```shell
   监视子进程：pid_t wait(int *status);
   ```

2. 解决wait()系统调用存在着一些限制

   ```shell
   pid_t waitpid(pid_t pid, int *status, int options);
   ```

## 6. 僵尸进程与孤儿进程

1. 孤儿进程：父进程先于子进程结束，也就是意味着，此时子进程变成了一个“孤儿”，我们把这种进程就称为孤儿 进程。在 Linux 系统当中，所有的孤儿进程都自动成为 init 进程（进程号为 1）的子进程，换言之，某一子 进程的父进程结束后，该子进程调用 getppid()将返回 1。

   /sbin/upstart 进程与 Ubuntu 系统图形化界面有关系，是图形化界面下的一个后台守护进程，可 负责“收养”孤儿进程，所以图形化界面下，upstart 进程就自动成为了孤儿进程的父进程。

2. 僵尸进程：进程结束之后，通常需要其父进程为其“收尸”，回收子进程占用的一些内存资源，父进程通过调用 wait()（或其变体 waitpid()、waitid()等）函数回收子进程资源，归还给系统。

   如果父进程创建了某一子进程，子进程已经结束，而父进程还在正常运行，但父进程并未调用 wait()回收子进程，此时子进程变成一个僵尸进程。

3. 子进程状态改变时（终止、暂停或恢复），父进程会收到 SIGCHLD 信号

## 7. 创建子进程执行新程序

1. 当子进程的工作不再是运行父进程的代码段，而是运行另一个新程 序的代码，那么这个时候子进程可以通过 exec 函数来实现运行另一个新的程序。exec 函数并不是指某一个函数、 而是 exec 族函数.

2. 系统调用 execve()可以将新程序加载到某一进程的内存空间，通过调用 execve()函数将一个外部的可执 行文件加载到进程的内存空间运行，使用新的程序替换旧的程序，而进程的栈、数据、以及堆数据会被新程 序的相应部件所替换，然后从新程序的 main()函数开始执行。

   ```shell
   int execve(const char *filename, char *const argv[], char *const envp[]);
   ```

## 8. 进程状态与进程关系

1. 进程状态：Linux 系统下进程通常存在 6 种不同的状态，分为：就绪态、运行态、僵尸态、可中断睡眠状态（浅度 睡眠）、不可中断睡眠状态（深度睡眠）以及暂停态。

   - 就绪态（Ready）：指该进程满足被 CPU 调度的所有条件但此时并没有被调度执行，只要得到 CPU 就能够直接运行；意味着该进程已经准备好被 CPU 执行，当一个进程的时间片到达，操作系统调 度程序会从就绪态链表中调度一个进程；
   - 运行态：指该进程当前正在被 CPU 调度运行，处于就绪态的进程得到 CPU 调度就会进入运行态；
   - 僵尸态：僵尸态进程其实指的就是僵尸进程，指该进程已经结束、但其父进程还未给它“收尸”；
   - 阻塞态，等待态：。把浅度睡眠和深度睡眠统称为等待态（或者叫阻塞态），表示进程处于一 种等待状态，等待某种条件成立之后便会进入到就绪态；所以，处于等待态的进程是无法参与进程系统调度的。
     + 可中断睡眠状态：可中断睡眠也称为浅度睡眠，表示睡的不够“死”，还可以被唤醒，一般来说可 以通过信号来唤醒；
     + 不可中断睡眠状态：不可中断睡眠称为深度睡眠，深度睡眠无法被信号唤醒，只能等待相应的条件 成立才能结束睡眠状态。
   - 暂停态：暂停并不是进程的终止，表示进程暂停运行，一般可通过信号将进程暂停，譬如 SIGSTOP 信号；处于暂停态的进程是可以恢复进入到就绪态的，譬如收到 SIGCONT 信号。
   
2. 进程各个状态之间的转换关系

   ![进程状态切换](C:..\image\进程状态切换.png)

3. 进程关系

   - 无关系

   - 父子进程关系

   - 进程组

     ```shell
     pid_t getpgid(pid_t pid);//参数 pid 为 0 表示获取调用者进程的进程组 ID。
     pid_t getpgrp(void);
     ```

     系统调用 setpgid()或 setpgrp()可以加入一个现有的进程组或创建一个新的进程组

     ```shel
     int setpgid(pid_t pid, pid_t pgid); //setpgid()函数将参数 pid 指定的进程的进程组 ID 设置为参数 gpid。如果这两个参数相等（pid==gpid）， 则由 pid 指定的进程变成为进程组的组长进程，创建了一个新的进程；如果参数 pid 等于 0，则使用调用者 的进程 ID；另外，如果参数 gpid 等于 0，则创建一个新的进程组，由参数 pid 指定的进程作为进程组组长 进程。
     int setpgrp(void);//一个进程只能为它自己或它的子进程设置进程组 ID，在它的子进程调用 exec 函数后，它就不能更改该 子进程的进程组 ID 了。
     ```

	- 系统调用 getsid()可以获取进程的会话 ID
	
	  ```shell
	  pid_t getsid(pid_t pid);//如果调用者进程不是进程组的组长进程，调用 setsid()将创建一个新的会话，调用者进程是新会话的首领进程，同样也是一个新的进程组的组长进程，调用 setsid()创建的会话将没有控制终端。			
	  ```

## 9 守护进程

1. 守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性 地执行某种任务或等待处理某些事情的发生，主要表现为以下两个特点：长期运行，与控制终端脱离。

   守护进程是一种很有用的进程。Linux 中大多数服务器就是用守护进程实现的，譬如，Internet 服务器 inetd、Web 服务器 httpd 等。同时，守护进程完成许多系统任务，譬如作业规划进程 crond 等。 守护进程 Daemon，通常简称为 d，一般进程名后面带有 d 就表示它是一个守护进程。守护进程与终端 无任何关联，用户的登录与注销与守护进程无关、不受其影响，守护进程自成进程组、自成会话，即 pid=gid=sid。通过命令"ps -ajx"查看系统所有的进程

2. 编写守护进程步骤

   - 创建子进程、终止父进程：父进程终止会让 shell 认为这条命令已经执行完毕；保证了子进程不是一个进程组的组长进程。
   - 子进程调用 setsid 创建会话：调用 setsid 有 三个作用：让子进程摆脱原会话的控制、让子进程摆脱原进程组的控制和让子进程摆脱原控制终端的控制。
   - 将工作目录更改为根目录通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其 它目录来作为守护进程的工作目录。
   - 重设文件权限掩码 umask：把文件权限掩 码设置为 0，确保子进程有最大操作权限、这样可以大大增强该守护进程的灵活性。设置文件权限掩码的函 数是 umask，通常的使用方法为 umask(0)。
   - 关闭不再需要的文件描述符：使得守护进程不再持有从其父进程继承过来的任何文件描述 符。
   - 将文件描述符号为 0、1、2 定位到/dev/null：将守护进程的标准输入、标准输出以及标准错误重定向到/dev/null，这使得守护进程的输出无处显示、 也无处从交互式用户那里接收输入。
   - 其它：忽略 SIGCHLD 信号：处理 SIGCHLD 信号不是必须的，但对于某些进程，特别是并发服务器进程往往是特别重要的，服务器 进程在接收到客户端请求时会创建子进程去处理该请求，如果子进程结束之后，父进程没有去 wait 回收子 进程，则子进程将成为僵尸进程；如果父进程 wait 等待子进程退出，将又会增加父进程的负担、也就是增 加服务器的负担，影响服务器进程的并发性能，在 Linux 下，可以将 SIGCHLD 信号的处理方式设置为 SIG_IGN，也就是忽略该信号，可让内核将僵尸进程转交给 init 进程去处理，这样既不会产生僵尸进程、又 省去了服务器进程回收子进程所占用的时间。

3. 当用户准备退出会话时，系统向该会话发出 SIGHUP 信号，会话将 SIGHUP 信号发送给所有子进程， 子进程接收到 SIGHUP 信号后，便会自动终止，当所有会话中的所有进程都退出时，会话也就终止.

## 10 单列模式运行

1. 单列模式：程序只能被执行一次，只要该程序没有结束，就无法 再次运行，我们把这种情况称为单例模式运行。譬如系统中守护进程，这些守护进程一般都是服务器进程， 服务器程序只需要运行一次即可。

   - 通过文件存在与否进行判断

   - 使用文件锁同样也需要通过一个特定的文件来实现，当程序启动之后，首先打开该文件，调用 open 时一般使用 O_WRONLY | O_CREAT 标志，当文件不存在则创建该文件，然后尝试去获取文件锁，若是成功，则将程序 的进程号（PID）写入到该文件中，写入后不要关闭文件或解锁（释放文件锁），保证进程一直持有该文件锁；若是程序获取锁失败，代表程序已经被运行、则退出本次启动。

     Tips：当程序退出或文件关闭之后，文件锁会自动解锁！

## 进程间通信/IPC

### 1. 进程间通信的机制分类

1. 总结
   - UNIX IPC：管道、FIFO、信号；
   - System V IPC：信号量、消息队列、共享内存；
   - POSIX IPC：信号量、消息队列、共享内存；
   - Socket IPC：基于 Socket 进程间通信。
   
2. 管道和FIFO：把一个进程连接到另一个进程的数据流称为管道，管道被抽象成一个文件
   - 普通管道 pipe：通常有两种限制，一是单工，数据只能单向传输；二是只能在父子或者兄弟进程间 使用；
   - 流管道 s_pipe：去除了普通管道的第一种限制，为半双工，可以双向传输；只能在父子或兄弟进程 间使用；
   - 有名管道 name_pipe（FIFO）：去除了普通管道的第二种限制，并且允许在不相关（不是父子或兄 弟关系）的进程间进行通讯。

3. 消息队列：消息队列是消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺陷。

4. 信号量：信号量是一个计数器，与其它进程间通信方式不大相同，它主要用于控制多个进程间或一个进程内的多 个线程间对共享资源的访问，相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志，除了用于共享资源的访问控制外，还可用于进程同步。

   它常作为一种锁机制，防止某进程在访问资源时其它进程也访问该资源，因此，主要作为进程间以及同 一个进程内不同线程之间的同步手段。

5. 共享内存：共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但其它的多个进程 都可以访问，使得多个进程可以访问同一块内存空间。

7. 套接字（Socket）：Socket 是一种 IPC 方法，是基于网络的 IPC 方法，允许位于同一主机（计算机）或使用网络连接起来 的不同主机上的应用程序之间交换数据，说白了就是网络通信
