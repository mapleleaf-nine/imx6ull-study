# 高级IO

## 1. 阻塞IO与非阻塞 I/O

1. 阻塞 I/O 与非阻塞 I/O 读文件

   - 阻塞式 I/O 和非阻塞式 I/O 对文件进行读操作，在调用 open()函数打开文件 时，为参数 flags 指定 O_NONBLOCK 标志，open()调用成功后，后续的 I/O 操作将以非阻塞式方式进行； 这就是非阻塞 I/O 的打开方式，如果未指定 O_NONBLOCK 标志，则默认使用阻塞式 I/O 进行操作。
   - 对于普通文件来说，指定与未指定 O_NONBLOCK 标志对其是没有影响，普通文件的读写操作是不会 阻塞的，它总是以非阻塞的方式进行 I/O 操作，这是普通文件本质上决定的

2. 阻塞 I/O 的优点与缺点

   - 当对文件进行读取操作时，如果文件当前无数据可读，那么阻塞式 I/O 会将调用者应用程序挂起、进入 休眠阻塞状态，直到有数据可读时才会解除阻塞；而对于非阻塞 I/O，应用程序不会被挂起，而是会立即返 回，它要么一直轮训等待，直到数据可读，要么直接放弃！
   - 所以阻塞式 I/O 的优点在于能够提升 CPU 的处理效率，当自身条件不满足时，进入阻塞状态，交出 CPU 资源，将 CPU 资源让给别人使用；而非阻塞式则是抓紧利用 CPU 资源，譬如不断地去轮训，这样就会导致 该程序占用了非常高的 CPU 使用率！

3. 使用非阻塞 I/O 实现并发读取

   - 设置标准输入为非阻塞方式：

     ```c
     int flag; 
     flag = fcntl(0, F_GETFL); //先获取原来的 flag 
     flag |= O_NONBLOCK; //将 O_NONBLOCK 标志添加到 flag 
     fcntl(0, F_SETFL, flag); //重新设置 flag
     ```
	- 非阻塞，将读取鼠标和读取键盘操作放入到一个循环中，通过轮训方式来实现并发读取鼠标和键盘

## 2. IO多路复用

- 虽然使用非阻塞式 I/O 解决了阻塞式 I/O 情况下并发读取文件所出现的问题，但依然不够完 美，使得程序的 CPU 占用率特别高。解决这个问题，就要用 I/O 多路复用方法。

1. I/O 多路复用

   - I/O 多路复用（IO multiplexing）它通过一种机制，可以监视多个文件描述符，一旦某个文件描述符（也 就是某个文件）可以执行 I/O 操作时，能够通知应用程序进行相应的读写操作。I/O 多路复用技术是为了解 决：在并发式 I/O 场景中进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。
   - I/O 多路复用一般用于并发式的非阻塞 I/O，也就是多路非阻塞 I/O，譬如程序中既要读取鼠 标、又要读取键盘，多路读取。
   - I/O 多路复用存在一个非常明显的特征：外部阻塞式，内部监视多路 I/O。

2. select()函数

   - 系统调用 select()可用于执行 I/O 多路复用操作，调用 select()会一直阻塞，直到某一个或多个文件描述 符成为就绪态（可以读或写）。

     ```c
     int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
     //select()函数的第一个参数 nfds 通常表示最大文件描述符编号值加 1，考虑 readfds、writefds 以及 exceptfds 这三个文件描述符集合，在 3 个描述符集中找出最大描述符编号值，然后加 1，这就是参数 nfds。
     //参数 readfds、writefds 以及 exceptfds 都是 fd_set 类型指针， 指向一个 fd_set 类型对象，fd_set 数据类型是一个文件描述符的集合体
     //readfds 是用来检测读是否就绪（是否可读）的文件描述符集合； //writefds 是用来检测写是否就绪（是否可写）的文件描述符集合； //exceptfds 是用来检测异常情况是否发生的文件描述符集合。
     //四个宏用于对 fd_set 类型对象进行操作:FD_CLR()、FD_ISSET()、FD_SET()、FD_ZERO()
     void FD_CLR(int fd, fd_set *set); //FD_CLR()将文件描述符 fd 从参数 set 所指向的集合中移除；
     int FD_ISSET(int fd, fd_set *set); //如果文件描述符 fd 是参数 set 所指向的集合中的成员，则 FD_ISSET()返回 true，否则返回 false。
     void FD_SET(int fd, fd_set *set); //FD_SET()将文件描述符 fd 添加到参数 set 所指向的集合中；
     void FD_ZERO(fd_set *set);//FD_ZERO()将参数 set 所指向的集合初始化为空
     //文件描述符集合有一个最大容量限制，有常量 FD_SETSIZE 来决定，在 Linux 系统下，该常量的值为 1024。在定义一个文件描述符集合之后，必须用 FD_ZERO()宏将其进行初始化操作，然后再向集合中添加 我们关心的各个文件描述符
     //如果这三个参数都设置为 NULL，则可以将 select()当做为一个类似于 sleep()休眠的函数来使用， 通过 select()函数的最后一个参数 timeout 来设置休眠时间。
     //返回值：返回-1 表示有错误发生，并且会设置 errno;返回 0 表示在任何文件描述符成为就绪态之前 select()调用已经超时；返回一个正整数表示有一个或多个文件描述符已达到就绪态。
     ```

   - select()函数将阻塞知道有以下事情发生：

     - readfds、writefds 或 exceptfds 指定的文件描述符中至少有一个称为就绪态；
     - 该调用被信号处理函数中断；
     - 参数 timeout 中指定的时间上限已经超时。

   - 如果要 在循环中重复调用 select()，我们必须保证每次都要重新初始化并设置 readfds、writefds、exceptfds 这些集合。

3. poll()函数

   - 系统调用 poll()与 select()函数很相似，但函数接口有所不同。在 select()函数中，我们提供三个 fd_set 集 合，在每个集合中添加我们关心的文件描述符；而在 poll()函数中，则需要构造一个 struct pollfd 类型的数 组，每个数组元素指定一个文件描述符以及我们对该文件描述符所关心的条件（数据可读、可写或异常情 况）

     ```c
     int poll(struct pollfd *fds, nfds_t nfds, int timeout);
     //fds：指向一个 struct pollfd 类型的数组，数组中的每个元素都会指定一个文件描述符以及我们对该文件 描述符所关心的条件，稍后介绍 struct pollfd 结构体类型。 
     //nfds：参数 nfds 指定了 fds 数组中的元素个数，数据类型 nfds_t 实际为无符号整形。 
     //timeout：该参数与 select()函数的 timeout 参数相似，用于决定 poll()函数的阻塞行为，具体用法如下：  如果 timeout 等于-1，则 poll()会一直阻塞（与 select()函数的 timeout 等于 NULL 相同），直到 fds 数组中列出的文件描述符有一个达到就绪态或者捕获到一个信号时返回。  如果 timeout 等于 0，poll()不会阻塞，只是执行一次检查看看哪个文件描述符处于就绪态。  如果 timeout 大于 0，则表示设置 poll()函数阻塞时间的上限值，意味着 poll()函数最多阻塞 timeout 毫秒，直到 fds 数组中列出的文件描述符有一个达到就绪态或者捕获到一个信号为止。
     struct pollfd { 
         int fd; /* file descriptor */ 
         short events; /* requested events */ 
         short revents; /* returned events */ 
     };
     //POLLIN有数据可以读取
     //POLLOUT可写入数据
     ```

   - 如果可以执行 I/O 操作时，应在应用程序中对该文件描述符执行 I/O 操作，以清除文 件描述符的就绪态，如果不清除就绪态，那么该状态将会一直存在，那么下一次调用 select()或者poll()时，文件描述 符已经处于就绪态了，将直接返回。

## 3. 异步IO

1. 异步IO概念

   - 在 I/O 多路复用中，进程通过系统调用 select()或 poll()来主动查询文件描述符上是否可以执行 I/O 操作。 而在异步 I/O 中，当文件描述符上可以执行 I/O 操作时，进程可以请求内核为自己发送一个信号。之后进程 就可以执行任何其它的任务直到文件描述符可以执行 I/O 操作为止，此时内核会发送信号给进程。所以要使 用异步 I/O，还得结合前面所学习的信号相关的内容，所以异步 I/O 通常也称为信号驱动 I/O。
   - 使用异步IO步骤
     -  通过指定 O_NONBLOCK 标志使能非阻塞 I/O。
     - 通过指定 O_ASYNC 标志使能异步 I/O。
     - 设置异步 I/O 事件的接收进程。也就是当文件描述符上可执行 I/O 操作时会发送信号通知该进程， 通常将调用进程设置为异步 I/O 事件的接收进程
     - 为内核发送的通知信号注册一个信号处理函数。默认情况下，异步 I/O 的通知信号是 SIGIO，所以 内核会给进程发送信号 SIGIO。
     - 以上步骤完成之后，进程就可以执行其它任务了，当 I/O 操作就绪时，内核会向进程发送一个 SIGIO 信号，当进程接收到信号时，会执行预先注册好的信号处理函数，我们就可以在信号处理函数中进 行 I/O 操作。

2. O_ASYNC 标志

   - O_ASYNC 标志可用于使能文件描述符的异步 I/O 事件，当文件描述符可执行 I/O 操作时，内核会向异 步 I/O 事件的接收进程发送 SIGIO 信号（默认情况下）。

   - 在调用 open()时无法通过指定 O_ASYNC 标志来使能异步 I/O，但可以使用 fcntl()函数 添加 O_ASYNC 标志使能异步 I/O

     ```c
     int flag; 
     flag = fcntl(0, F_GETFL); //先获取原来的 flag 
     flag |= O_ASYNC; //将 O_ASYNC 标志添加到 flag 
     fcntl(fd, F_SETFL, flag); //重新设置 flag
     ```

3. 设置异步 I/O 事件的接收进程

   - 为文件描述符设置异步 I/O 事件的接收进程，也就是设置异步 I/O 的所有者。同样也是通过 fcntl()函数 进行设置，操作命令 cmd 设置为 F_SETOWN，第三个参数传入接收进程的进程 ID（PID），通常将调用进 程的 PID 传入

     ```c
     fcntl(fd, F_SETOWN, getpid());
     ```

4. 注册 SIGIO 信号的处理函数

   - 通过 signal()或 sigaction()函数为 SIGIO 信号注册一个信号处理函数，当进程接收到内核发送过来的 SIGIO 信号时，会执行该处理函数，所以我们应该在处理函数当中执行相应的 I/O 操作。

     ```c
     signal(SIGIO, sigio_handler);
     //实现static void sigio_handler(int sig)
     ```

5. 优化异步IO

   - select()或 poll()函数来说，内部实现原理其实是通过轮训的方式来检查多个文件描述符是否可执 行 I/O 操作，所以，当需要检查的文件描述符数量较多时，随之也将会消耗大量的 CPU 资源来实现轮训检 查操作

   - 当需要检查大量文件描述符时，可以使用 epoll 解决 select()或 poll()性能低的问题；在性能表现上，epoll 与异步 I/O 方式相似

   - 默认异步IO缺点：

     + 默认的异步 I/O 通知信号 SIGIO 是非排队信号。SIGIO 信号是标准信号（非实时信号、不可靠信 号），所以它不支持信号排队机制，譬如当前正在执行 SIGIO 信号的处理函数，此时内核又发送 多次 SIGIO 信号给进程，这些信号将会被阻塞，只有当信号处理函数执行完毕之后才会传递给进 程，并且只能传递一次，而其它后续的信号都会丢失。
     + 无法得知文件描述符发生了什么事件。是可读取还是可写入亦或者 发生异常等。

   - 改进：使用实时信号替换默认信号 SIGIO：使用 fcntl()函数进行设置，调用函数时将操作命令 cmd 参数设置为 F_SETSIG，第三个参数 arg 指定一个实时信号编号即可，表示将该信号作为异步 I/O 通知信号

     ```c
     fcntl(fd, F_SETSIG, SIGRTMIN);
     ```

   - 改进：使用 sigaction()函数注册信号处理函数:在应用程序当中需要为实时信号注册信号处理函数，使用 sigaction 函数进行注册，并为 sa_flags 参数指 定 SA_SIGINFO，表示使用 sa_sigaction 指向的函数作为信号处理函数，而不使用 sa_handler 指向的函数。 因为 sa_sigaction 指向的函数作为信号处理函数提供了更多的参数，可以获取到更多信息，

     + 函数参数中包括一个 siginfo_t 指针，指向 siginfo_t 类型对象，当触发信号时该对象由内核构建,
     +  siginfo_t结构体中si_code：表示文件描述符 si_fd 发生了什么事件，读就绪态、写就绪态或者是异常事件等。

   - 使用实时信号+sigaction 解决：默认 异步 I/O 通知信号 SIGIO 可能存在丢失以及信号处理函数中无法判断文件描述符所发生的 I/O 事件这两个 问题。

## 4. 存储映射 I/O

   - 存储映射 I/O（memory-mapped I/O）是一种基于内存区域的高级 I/O 操作，它能将一个文件映射到进程 地址空间中的一块内存区域中，当从这段内存中读数据时，就相当于读文件中的数据（对文件进行 read 操 作），将数据写入这段内存时，则相当于将数据直接写入文件中（对文件进行 write 操作）。这样就可以在 不使用基本 I/O 操作函数 read()和 write()的情况下执行 I/O 操作。

1. mmap()和 munmap()函数

   - 为了实现存储映射 I/O 这一功能，我们需要告诉内核将一个给定的文件映射到进程地址空间中的一块 内存区域中，这由系统调用 mmap()来实现。

     ```c
     void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
     //addr：参数 addr 用于指定映射到内存区域的起始地址。通常将其设置为 NULL，这表示由系统选择该 映射区的起始地址，这是最常见的设置方式；如果参数 addr 不为 NULL，则表示由自己指定映射区的起始 地址，此函数的返回值是该映射区的起始地址。
     //length：参数 length 指定映射长度，表示将文件中的多大部分映射到内存区域中，以字节为单位，譬如 length=1024 * 4，表示将文件的 4K 字节大小映射到内存区域中。
     //offset：文件映射的偏移量，通常将其设置为 0，表示从文件头部开始映射；所以参数 offset 和参数 length 就确定了文件的起始位置和长度，将文件的这部分映射到内存区域中
     //offset：文件映射的偏移量，通常将其设置为 0，表示从文件头部开始映射；所以参数 offset 和参数 length 就确定了文件的起始位置和长度，将文件的这部分映射到内存区域中
     //prot：参数 prot 指定了映射区的保护要求，可取值：
     //PROT_EXEC：映射区可执行；
     //PROT_READ：映射区可读；
     //PROT_WRITE：映射区可写；
     //PROT_NONE：映射区不可访问。
     //flags：参数 flags 可影响映射区的多种属性，参数 flags 必须要指定以下两种标志之一：
     //MAP_SHARED：此标志指定当对映射区写入数据时，数据会写入到文件中，也就是会将写入到映 射区中的数据更新到文件中，并且允许其它进程共享。
     //MAP_PRIVATE：此标志指定当对映射区写入数据时，会创建映射文件的一个私人副本（copy-onwrite），对映射区的任何操作都不会更新到文件中，仅仅只是对文件副本进行读写。
     //除此之外，还可将以下标志中的 0 个或多个组合到参数 flags 中，通过按位或运算符进行组合：
     //通常情况下，参数 flags 中只指定了 MAP_SHARED。
     //返回值：成功情况下，函数的返回值便是映射区的起始地址；发生错误时，返回(void *)-1，通常使用 MAP_FAILED 来表示，并且会设置 errno 来指示错误原因。
     ```

   - ![存储映射IO示意图](..\image\存储映射IO示意图.jpg)

   - 对于 mmap()函数，参数 addr 和 offset 在不为 NULL 和 0 的情况下，addr 和 offset 的值通常被要求是系 统页大小的整数倍，可通过 sysconf()函数获取页大小，如下所示（以字节为单位）：

     ```c
     sysconf(_SC_PAGE_SIZE) 
     或 sysconf(_SC_PAGESIZE)
     ```

   - 与映射区相关的两个信号

     ```c
     SIGSEGV：如果映射区被 mmap()指定成了只读的，那么进程试图将数据写入到该映射区时，将会 产生 SIGSEGV 信号，此信号由内核发送给进程。该信号的系统 默认操作是终止进程、并生成核心可用于调试的核心转储文件。
     SIGBUS：如果映射区的某个部分在访问时已不存在，则会产生 SIGBUS 信号。例如，调用 mmap() 进行映射时，将参数 length 设置为文件长度，但在访问映射区之前，另一个进程已将该文件截断 （譬如调用 ftruncate()函数进行截断），此时如果进程试图访问对应于该文件已截去部分的映射区， 进程将会受到内核发送过来的 SIGBUS 信号，同样，该信号的系统默认操作是终止进程、并生成 核心可用于调试的核心转储文件。
     ```

   - 通过 mmap()将文件映射到进程地址空间中 的一块内存区域中，当不再需要时，必须解除映射，使用 munmap()解除映射关系

     ```c
     int munmap(void *addr, size_t length);
     //munmap()系统调用解除指定地址范围内的映射，参数 addr 指定待解除映射地址范围的起始地址，它必 须是系统页大小的整数倍；参数 length 是一个非负整数，指定了待解除映射区域的大小（字节数），被解除 映射的区域对应的大小也必须是系统页大小的整数倍，即使参数 length 并不等于系统页大小的整数倍，与 mmap()函数相似。
     ```

   - 需要注意的是，当进程终止时也会自动解除映射（如果程序中没有显式调用 munmap()），但调用 close() 关闭文件时并不会解除映射。

   - 通常将参数 addr 设置为 mmap()函数的返回值，将参数 length 设置为 mmap()函数的参数 length，表示解 除整个由 mmap()函数所创建的映射。

2. mprotect()函数

   - 使用系统调用 mprotect()可以更改一个现有映射区的保护要求

     ```c
     int mprotect(void *addr, size_t len, int prot);
     //参数 prot 的取值与 mmap()函数的 prot 参数的一样，mprotect()函数会将指定地址范围的保护要求更改 为参数 prot 所指定的类型，参数 addr 指定该地址范围的起始地址，addr 的值必须是系统页大小的整数倍； 参数 len 指定该地址范围的大小。 
     //mprotect()函数调用成功返回 0；失败将返回-1，并且会设置 errno 来只是错误原因。
     ```

3. msync()函数

   - 我们可以调用 msync()函数将映射区中的数据刷写、更新至磁盘文件中（同步操作）， 系统调用 msync()类似于 fsync()函数，不过 msync()作用于映射区

     ```c
     int msync(void *addr, size_t length, int flags);
     //参数 flags 应指定为 MS_ASYNC 和 MS_SYNC 两个标志之一，除此之外，还可以根据需求选择是否指 定 MS_INVALIDATE 标志，作为一个可选标志。
     //MS_ASYNC：以异步方式进行同步操作。调用 msync()函数之后，并不会等待数据完全写入磁盘之 后才返回;
     //MS_SYNC：以同步方式进行同步操作。调用 msync()函数之后，需等待数据全部写入磁盘之后才 返回。
     //MS_INVALIDATE：是一个可选标志，请求使同一文件的其它映射无效（以便可以用刚写入的新 值更新它们）。
     ```

4. 普通 I/O 与存储映射 I/O 比较

   - 普通 I/O 方式的缺点：普通 I/O 方式一般是通过调用 read()和 write()函数来实现对文件的读写，使用 read()和 write()读写文件 时，函数经过层层的调用后，才能够最终操作到文件，中间涉及到很多的函数调用过程，数据需要在不同的 缓存间倒腾，效率会比较低。同样使用标准 I/O（库函数 fread()、fwrite()）也是如此，本身标准 I/O 就是对 普通 I/O 的一种封装。

   - 存储映射 I/O 的优点：存储映射 I/O 的实质其实是共享，与 IPC 之内存共享很相似。譬如执行一个文件复制操作来说，对于普 通 I/O 方式，首先需要将源文件中的数据读取出来存放在一个应用层缓冲区中，接着再将缓冲区中的数据写 入到目标文件中

     而对于存储映射 I/O 来说，由于源文件和目标文件都已映射到了应用层的内存区域中，所以直接操作映 射区来实现文件复制

     通过存储映射 I/O 将文件直接映射到应用程序地址空间中的一块内存区域中，也就是映射区；直接 将磁盘文件直接与映射区关联起来，不用调用 read()、write()系统调用，直接对映射区进行读写操作即可操 作磁盘上的文件，而磁盘文件中的数据也可反应到映射区中，这就是一种共享，可以认为映射区就是应用层 与内核层之间的共享内存。

   - 存储映射 I/O 的不足：存储映射 I/O 方式并不是完美的，它所映射的文件只能是固定大小，因为文件所映射的区域已经在调用 mmap()函数时通过 length 参数指定了。另外，文件映射的内存区域的大小必须是系统页大小的整数倍

   - 存储映射 I/O 在处理大量数据时效率高，对于少量数据处理不是很划算，所以通常来 说，存储映射 I/O 会在视频图像处理方面用的比较多，譬如在第二篇内容，我们将会介绍 Framebuffer 编程， 通俗点说就是 LCD 编程，就会使用到存储映射 I/O。

## 5. 文件锁

- 互斥锁、自旋 锁、读写锁主要用在多线程环境下，对共享资源的访问进行保护，做到线程同步。
- 文件锁，顾名思义是一种应用于文件的锁机制，当多个进程同时操作同一文件时，我们怎么保证文件 数据的正确性，linux 通常采用的方法是对文件上锁，来避免多个进程同时操作同一文件时产生竞争状态。
- 文件锁可以分为建议性锁和强制性锁两种：
  - 建议性锁：建议性锁本质上是一种协议，程序访问文件之前，先对文件上锁，上锁成功之后再访问文件
  - 强制性锁：强制性锁比较好理解，它是一种强制性的要求，如果进程对文件上了强制性锁，其它的进程在没有获取 到文件锁的情况下是无法对文件进行访问的。
  - 在 Linux 系统中，可以调用 flock()、fcntl()以及 lockf()这三个函数对文件上锁

1. flock()函数加锁

   - 系统调用 flock()，使用该函数可以对文件加锁或者解锁，但是 flock()函数只能产生建议性锁

     ```c
     int flock(int fd, int operation);
     //operation：参数 operation 指定了操作方式，可以设置为以下值的其中一个：
     //LOCK_SH：在 fd 引用的文件上放置一把共享锁。所谓共享，指的便是多个进程可以拥有对同一 个文件的共享锁，该共享锁可被多个进程同时拥有。
     //LOCK_EX：在 fd 引用的文件上放置一把排它锁（或叫互斥锁）。所谓互斥，指的便是互斥锁只 能同时被一个进程所拥有。
     //LOCK_UN：解除文件锁定状态，解锁、释放锁。
     //LOCK_NB：表示以非阻塞方式获取锁。默认情况下，调用 flock()无法获取到文件锁时会阻塞、直 到其它进程释放锁为止，如果不想让程序被阻塞，可以指定 LOCK_NB 标志，如果无法获取到锁 应立刻返回（错误返回，并将 errno 设置为 EWOULDBLOCK），通常与 LOCK_SH 或 LOCK_EX 一起使用，通过位或运算符组合在一起。
     //对于 flock()，需要注意的是，同一个文件不会同时具有共享锁和互斥锁。
     ```

   - 关于 flock()的几条规则

     - 同一进程对文件多次加锁不会导致死锁。
     - 文件关闭的时候，会自动解锁。
     - 一个进程不可以对另一个进程持有的文件锁进行解锁。
     - 由 fork()创建的子进程不会继承父进程所创建的锁。

   - 当一个文件描述符被复制时（譬如使用 dup()、dup2()或 fcntl()F_DUPFD 操作），这些通过 复制得到的文件描述符和源文件描述符都会引用同一个文件锁，使用这些文件描述符中的任何一个进行解 锁都可以

2. fcntl()函数加锁

   - 多功能文件描述符管理工具箱，通过配合不同 的 cmd 操作命令来实现不同的功能

     ```c
     int fcntl(int fd, int cmd, ... /* struct flock *flockptr */ );
     //与锁相关的 cmd 为 F_SETLK、F_SETLKW、F_GETLK，第三个参数 flockptr 是一个 struct flock 结构体 指针。使用 fcntl()实现文件锁功能与 flock()有两个比较大的区别：
     //flock()仅支持对整个文件进行加锁/解锁；而 fcntl()可以对文件的某个区域（某部分内容）进行加锁 /解锁，可以精确到某一个字节数据。
     //flock()仅支持建议性锁类型；而 fcntl()可支持建议性锁和强制性锁两种类型。
     //F_GETLK：这种用法一般用于测试
     //F_SETLK：对文件添加由 flockptr 指向的 struct flock 对象所描述的锁
     //F_SETLKW：此命令是 F_SETLK 的阻塞版本（命令名中的 W 表示等待 wait）
     ```

   - struct flock 结构体

     ```c
     struct flock { 
         ... 
         short l_type; /* Type of lock: F_RDLCK,F_WRLCK, F_UNLCK */ 
         short l_whence; /* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END */ 
         off_t l_start; /* Starting offset for lock */ 
         off_t l_len; /* Number of bytes to lock */ 
         pid_t l_pid; /* PID of process blocking our lock(set by F_GETLK and F_OFD_GETLK) */ 
         ...
     };
     //，F_RDLCK 表示共享性质的读锁，F_WRLCK 表示独占性质的写锁，F_UNLCK 表示解锁一个区域。
     //l_whence 和 l_start：这两个变量用于指定要加锁或解锁区域的起始字节偏移量，与lseek()函数中的 offset 和 whence 参数相同
     //l_len：需要加锁或解锁区域的字节长度。
     //l_pid：一个 pid，指向一个进程，表示该进程持有的锁能阻塞当前进程，当 cmd=F_GETLK 时有效。
     ```

   - 几条规则

     - 文件关闭的时候，会自动解锁。
     - 一个进程不可以对另一个进程持有的文件锁进行解锁。
     - 由 fork()创建的子进程不会继承父进程所创建的锁。

   - 当一个文件描述符被复制时（譬如使用 dup()、dup2()或 fcntl()F_DUPFD 操作），这些通过 复制得到的文件描述符和源文件描述符都会引用同一个文件锁，使用这些文件描述符中的任何一个进行解 锁都可以，这点与 flock()是一样的

3. lockf()函数加锁

   - lockf()函数是一个库函数，其内部是基于 fcntl()来实现的，所以 lockf()是对 fcntl 锁的一种封装

